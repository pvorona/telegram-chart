"use strict";

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

(function () {
  'use strict';

  var _TRANSITION_DURATIONS, _NEXT_THEME, _LABELS, _THEME_CLASS_NAMES;

  var MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
  var DAYS = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
  var LIGHT = 0;
  var DARK = 1;
  var ELEMENT_CLASS_NAME = 'title';

  function Title(title) {
    var element = document.createElement('div');
    element.className = ELEMENT_CLASS_NAME;
    element.innerText = title;
    return element;
  }

  function handleDrag(element, _ref) {
    var onDragStart = _ref.onDragStart,
        onDragMove = _ref.onDragMove,
        onDragEnd = _ref.onDragEnd;
    element.addEventListener('mousedown', onStart);
    element.addEventListener('touchstart', onStart);

    function onStart(e) {
      e.preventDefault();
      e.stopPropagation();

      switch (event.type) {
        case 'mousedown':
          if (event.which === 1) {
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onEnd);
            onDragStart(e);
          }

          break;

        case 'touchstart':
          document.addEventListener('touchmove', onMove);
          document.addEventListener('touchend', onEnd);
          onDragStart(e.touches[0]);
          break;
      }
    }

    function onMove(e) {
      switch (event.type) {
        case 'mousemove':
          onDragMove(e);
          break;

        case 'touchmove':
          onDragMove(e.touches[0]);
          break;
      }
    }

    function onEnd(e) {
      switch (e.type) {
        case 'mouseup':
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onEnd);
          onDragEnd(e);
          break;

        case 'touchend':
          document.removeEventListener('touchmove', onMove);
          document.removeEventListener('touchend', onEnd);
          onDragEnd(e.touches[0]);
          break;
      }
    }
  }

  function easing(t) {
    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  }

  function animate(from, to, duration, callback) {
    var startAnimationTime = Date.now();
    var lastDispatchedValue = from;
    var animating = true;
    var animationId;

    function frame() {
      var currentTime = Date.now();

      if (currentTime - startAnimationTime >= duration) {
        if (lastDispatchedValue !== to) {
          callback(to);
        }

        animating = false;
      } else {
        var currentValue = easing((currentTime - startAnimationTime) / duration) * (to - from) + from;
        callback(currentValue);
        lastDispatchedValue = currentValue;
        animationId = requestAnimationFrame(frame);
      }
    }

    animationId = requestAnimationFrame(frame);
    return function cancelAnimation() {
      if (animating) {
        cancelAnimationFrame(animationId);
      }
    };
  }

  function getShortNumber(num) {
    if (Math.abs(num) < 1000) {
      return num;
    }

    var shortNumber;
    var exponent;
    var size;
    var suffixes = {
      'K': 6,
      'M': 9,
      'B': 12,
      'T': 16
    };
    num = Math.abs(num);
    size = Math.floor(num).toString().length;
    exponent = size % 3 === 0 ? size - 3 : size - size % 3;
    shortNumber = Math.round(10 * (num / Math.pow(10, exponent))) / 10;

    for (var suffix in suffixes) {
      if (exponent < suffixes[suffix]) {
        shortNumber += suffix;
        break;
      }
    }

    return shortNumber;
  }

  var max = Math.max,
      ceil = Math.ceil,
      floor = Math.floor,
      pow = Math.pow;

  function interpolatePoint(point, values) {
    return interpolate(floor(point), ceil(point), values[floor(point)], values[ceil(point)], point);
  }

  function interpolate(x1, x2, y1, y2, x) {
    if (x === x2) return y2;
    return (y2 - y1) / (x2 - x1) * (x - x1) + y1;
  } // h = H * w / W
  // O(n)


  function mapDataToCoords(data, max, targetContainer, _ref2) {
    var startIndex = _ref2.startIndex,
        endIndex = _ref2.endIndex;
    var coords = [];

    if (!Number.isInteger(startIndex)) {
      coords.push({
        x: 0,
        y: targetContainer.height - targetContainer.height / max * interpolatePoint(startIndex, data)
      });
    }

    for (var i = ceil(startIndex); i <= floor(endIndex); i++) {
      coords.push({
        x: targetContainer.width / (endIndex - startIndex) * (i - startIndex),
        y: targetContainer.height - targetContainer.height / max * data[i]
      });
    }

    if (!Number.isInteger(endIndex)) {
      coords.push({
        x: targetContainer.width,
        y: targetContainer.height - targetContainer.height / max * interpolatePoint(endIndex, data)
      });
    }

    return coords;
  }

  function findMaxElement(values, _ref3) {
    var startIndex = _ref3.startIndex,
        endIndex = _ref3.endIndex;
    var maxValue = values[0][ceil(startIndex)];

    for (var j = 0; j < values.length; j++) {
      maxValue = max(maxValue, interpolatePoint(startIndex, values[j]), interpolatePoint(endIndex, values[j]));

      for (var i = ceil(startIndex); i <= endIndex; i++) {
        maxValue = max(values[j][i], maxValue);
      }
    }

    return maxValue;
  }

  function getMaxValue(viewBox, values) {
    var max = findMaxElement(values, viewBox);
    if (max % 50 === 0) return max; // if (max % 5 === 0) return max

    return max + (50 - max % 50);
  }

  function createElement(type) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var element = document.createElement(type);
    Object.assign(element, attributes);
    children.forEach(function (child) {
      return element.appendChild(child);
    });
    return element;
  }

  var div = function div() {
    return document.createElement('div');
  };

  var LEGEND_ITEM_CLASS = 'legend-item-value';
  var LEGEND_ITEM_HIDDEN_CLASS = 'legend-item-value--hidden';
  var APPROX_LABEL_WIDTH = 40;

  function XAxis(_ref4) {
    var points = _ref4.points,
        viewBox = _ref4.viewBox,
        width = _ref4.width;
    var element = div();
    element.className = 'x-axis';
    element.style.width = "".concat(width, "px");
    var shiftingContainer = div();
    shiftingContainer.className = 'shifting-container';
    element.appendChild(shiftingContainer);
    var legendValues = [];
    var valuesWidths = [];

    for (var i = 0; i < points.length; i++) {
      var xValueElement = div();
      xValueElement.innerText = points[i].label;
      xValueElement.className = LEGEND_ITEM_CLASS;
      legendValues.push(xValueElement);
      shiftingContainer.appendChild(xValueElement);
    }

    setViewBox(viewBox);
    return {
      element: element,
      setViewBox: setViewBox
    };

    function setViewBox(viewBox) {
      var stepMiltiplier = calculateMultiplier(viewBox.endIndex - viewBox.startIndex);
      var xScale = (viewBox.endIndex - viewBox.startIndex) / (points.length - 1);
      var shift = -1 / xScale * width * viewBox.startIndex / (points.length - 1);
      shiftingContainer.style.transform = "translateX(".concat(shift, "px)");

      for (var _i = 0; _i < points.length; _i++) {
        var _xValueElement = legendValues[_i];
        var offset = points[_i].x / xScale;
        _xValueElement.style.transform = "translateX(".concat(offset, "px)");

        if (!valuesWidths[_i]) {
          valuesWidths[_i] = _xValueElement.offsetWidth || APPROX_LABEL_WIDTH;
        }

        _xValueElement.classList.toggle(LEGEND_ITEM_HIDDEN_CLASS, _i % pow(2, stepMiltiplier) || offset < -1 * shift || valuesWidths[_i] + offset + shift > width);
      }
    }
  }

  function calculateMultiplier(n) {
    for (var i = 3; i < 50; i++) {
      if (n < pow(2, i)) return i - 3;
    }
  }

  var CLASS = 'y-axis-line';
  var NUMBER_CLASS = 'y-axis-number';
  var STEP_COUNT = 5;
  var NUMBER_VERTICAL_PADDING = 5;
  var NUMBER_VERTICAL_SPACE = 18;

  function YAxis(max, height) {
    var element = document.createDocumentFragment();
    var elements = [];
    var step = height / STEP_COUNT;

    for (var i = 0; i < STEP_COUNT; i++) {
      var line = document.createElement('div');
      line.className = CLASS;
      line.style.transform = "translateY(".concat(-step * i, "px)");
      var number = document.createElement('div');
      number.className = NUMBER_CLASS;
      number.innerText = getShortNumber(max / STEP_COUNT * i);
      number.style.transform = "translateY(".concat(-step * i - NUMBER_VERTICAL_PADDING, "px)");
      elements.push({
        line: line,
        number: number,
        bottom: step * i
      });
      element.appendChild(number);
      element.appendChild(line);
    }

    return {
      element: element,
      setMax: setMax
    };

    function setMax(newMax) {
      elements.forEach(function (element) {
        var y = max / newMax * element.bottom;
        element.line.style.transform = "translateY(".concat(-1 * y, "px)");
        element.number.style.transform = "translateY(".concat(-1 * (y + NUMBER_VERTICAL_PADDING), "px)");

        if (y + NUMBER_VERTICAL_PADDING + NUMBER_VERTICAL_SPACE >= height) {
          element.line.style.opacity = 0;
          element.number.style.opacity = 0;
        } else {
          element.line.style.opacity = 1;
          element.number.style.opacity = 1;
        }
      });
    }
  }

  var TOGGLE_VISIBILITY_STATE = 0;
  var VIEW_BOX_CHANGE = 1;

  function Tooltip(_ref5) {
    var graphNames = _ref5.graphNames,
        colors = _ref5.colors;
    var element = document.createElement('div');
    element.className = 'tooltip';
    var tooltipDate = document.createElement('div');
    tooltipDate.style.padding = '10px 10px 0';
    element.appendChild(tooltipDate);
    var tooltipLegendContainer = document.createElement('div');
    tooltipLegendContainer.className = 'tooltip__legend';
    element.appendChild(tooltipLegendContainer);
    var tooltipValues = {};
    var graphInfos = {};
    graphNames.forEach(function (graphName) {
      var tooltipGraphInfo = document.createElement('div');
      tooltipGraphInfo.style.color = colors[graphName];
      tooltipGraphInfo.style.padding = '0 10px 10px';
      graphInfos[graphName] = tooltipGraphInfo;
      var tooltipValue = document.createElement('div');
      tooltipValue.style.fontWeight = 'bold';
      tooltipGraphInfo.appendChild(tooltipValue);
      var graphNameElement = document.createElement('div');
      graphNameElement.innerText = graphName;
      tooltipGraphInfo.appendChild(graphNameElement);
      tooltipValues[graphName] = tooltipValue;
      tooltipLegendContainer.appendChild(tooltipGraphInfo);
    });
    return {
      element: element,
      show: show,
      hide: hide,
      setPosition: setPosition,
      setDate: setDate,
      showValues: showValues
    };

    function show() {
      element.style.visibility = 'visible';
    }

    function hide() {
      element.style.visibility = '';
    }

    function setPosition(x) {
      element.style.transform = "translateX(calc(".concat(x, "px - 50%))");
    }

    function setDate(text) {
      tooltipDate.innerText = getTooltipDateText(text);
    }

    function showValues(value) {
      for (var graphName in tooltipValues) {
        graphInfos[graphName].hidden = true;
      }

      for (var _graphName in value) {
        graphInfos[_graphName].hidden = false;
        tooltipValues[_graphName].innerText = getShortNumber(value[_graphName]);
      }
    }
  }

  function getTooltipDateText(timestamp) {
    var date = new Date(timestamp);
    return "".concat(DAYS[date.getDay()], ", ").concat(MONTHS[date.getMonth()], " ").concat(date.getDate());
  }

  var DOT_BORDER_SIZE = 2;
  var DOT_SIZE = 10;
  var CENTER_OFFSET = -DOT_SIZE / 2 - DOT_BORDER_SIZE;

  function TooltipCircle(_ref6) {
    var color = _ref6.color;
    var element = document.createElement('div');
    element.style.width = "".concat(DOT_SIZE, "px");
    element.style.height = "".concat(DOT_SIZE, "px");
    element.style.borderColor = color;
    element.className = 'tooltip__dot';
    return {
      element: element,
      hide: hide,
      show: show,
      setPosition: setPosition
    };

    function show() {
      element.style.visibility = 'visible';
    }

    function hide() {
      element.style.visibility = '';
    }

    function setPosition(_ref7) {
      var x = _ref7.x,
          y = _ref7.y;
      element.style.transform = "translateX(".concat(x + CENTER_OFFSET, "px) translateY(").concat(y + CENTER_OFFSET, "px)");
    }
  }

  var LINE_WIDTH = 1;

  function TooltipLine() {
    var element = document.createElement('div');
    element.className = 'tooltip-line';
    return {
      element: element,
      show: show,
      hide: hide,
      setPosition: setPosition
    };

    function show() {
      element.style.visibility = 'visible';
    }

    function hide() {
      element.style.visibility = '';
    }

    function setPosition(x) {
      element.style.transform = "translateX(".concat(x - LINE_WIDTH / 2, "px)");
    }
  }

  var CLASS_NAME = 'graph';
  var HIDDEN_LAYER_CLASS = 'graph--hidden';

  function Graph(_ref8) {
    var width = _ref8.width,
        height = _ref8.height,
        strokeStyle = _ref8.strokeStyle,
        lineWidth = _ref8.lineWidth;
    var element = document.createElement('canvas');
    element.style.width = "".concat(width, "px");
    element.style.height = "".concat(height, "px");
    element.width = width * devicePixelRatio;
    element.height = height * devicePixelRatio;
    element.className = CLASS_NAME;
    var context = element.getContext('2d');
    context.strokeStyle = strokeStyle;
    context.lineWidth = lineWidth * devicePixelRatio;
    return {
      element: element,
      toggleVisibility: toggleVisibility,
      clear: clear,
      renderPath: renderPath
    };

    function toggleVisibility() {
      element.classList.toggle(HIDDEN_LAYER_CLASS);
    }

    function clear() {
      context.clearRect(0, 0, width * devicePixelRatio, height * devicePixelRatio);
    }

    function renderPath(points) {
      context.beginPath();

      for (var i = 0; i < points.length; i++) {
        var _points$i = points[i],
            x = _points$i.x,
            y = _points$i.y;
        context.lineTo(x, y);
      }

      context.stroke();
    }
  }

  function EmptyState() {
    var element = document.createElement('div');
    element.className = 'empty-state';
    element.innerText = 'Nothing to show';
    element.style.opacity = 0;
    return {
      element: element,
      setVisibile: setVisibile
    };

    function setVisibile(visible) {
      element.style.opacity = visible ? 0 : 1;
    }
  }

  var TRANSITION_DURATIONS = (_TRANSITION_DURATIONS = {}, _defineProperty(_TRANSITION_DURATIONS, VIEW_BOX_CHANGE, 250), _defineProperty(_TRANSITION_DURATIONS, TOGGLE_VISIBILITY_STATE, 250), _TRANSITION_DURATIONS); // graphNames, colors, visibilityStte, data

  function Graphs(config, _ref9) {
    var width = _ref9.width,
        height = _ref9.height,
        lineWidth = _ref9.lineWidth,
        strokeStyles = _ref9.strokeStyles,
        _ref9$viewBox = _ref9.viewBox,
        startIndex = _ref9$viewBox.startIndex,
        endIndex = _ref9$viewBox.endIndex,
        showXAxis = _ref9.showXAxis,
        showYAxis = _ref9.showYAxis,
        showTooltip = _ref9.showTooltip,
        top = _ref9.top;
    var element = document.createDocumentFragment();
    var canvasesContainer = div();
    var viewBox = {
      startIndex: startIndex,
      endIndex: endIndex
    };
    var max = getMaxValue(viewBox, getArrayOfDataArrays(config.graphNames));
    var yAxis;

    if (showYAxis) {
      yAxis = YAxis(max, height);
      canvasesContainer.appendChild(yAxis.element);
    }

    canvasesContainer.style.width = "".concat(width, "px");
    canvasesContainer.style.height = "".concat(height, "px");
    canvasesContainer.className = 'graphs';
    if (top) canvasesContainer.style.top = "".concat(top, "px");
    var canvases = {};

    for (var i = 0; i < config.graphNames.length; i++) {
      var graph = Graph({
        width: width,
        height: height,
        lineWidth: lineWidth,
        strokeStyle: strokeStyles[config.graphNames[i]]
      });
      canvases[config.graphNames[i]] = graph;
      canvasesContainer.appendChild(graph.element);
    }

    var tooltipLine;
    var tooltip;
    var tooltipDots;

    if (showTooltip) {
      canvasesContainer.addEventListener('mousemove', onContainerMouseMove);
      canvasesContainer.addEventListener('mouseout', onContainerMouseOut);
      tooltipLine = TooltipLine();
      canvasesContainer.appendChild(tooltipLine.element);
      tooltip = Tooltip({
        graphNames: config.graphNames,
        colors: config.colors
      });
      tooltipDots = {};

      for (var _i2 = 0; _i2 < config.graphNames.length; _i2++) {
        var tooltipCircle = TooltipCircle({
          color: config.colors[config.graphNames[_i2]]
        });
        canvasesContainer.appendChild(tooltipCircle.element);
        tooltipDots[config.graphNames[_i2]] = tooltipCircle;
      }

      canvasesContainer.appendChild(tooltip.element);
    }

    var emprtState = EmptyState();
    canvasesContainer.appendChild(emprtState.element);
    element.appendChild(canvasesContainer);
    var dragging = false;
    var cancelAnimation;
    var currentAnimationTarget;
    var transitionDuration;
    var xAxis;

    if (showXAxis) {
      xAxis = XAxis({
        points: getXAxisPoints(),
        viewBox: viewBox,
        width: width
      });
      element.appendChild(xAxis.element);
    }

    render();
    return {
      element: element,
      changeViewBox: changeViewBox,
      toggleVisibility: toggleVisibility,
      startDrag: startDrag,
      stopDrag: stopDrag
    };

    function update() {
      var visibleGraphNames = config.graphNames.filter(function (graphName) {
        return config.visibilityState[graphName];
      });
      if (!visibleGraphNames.length) return;
      var arrayOfDataArrays = getArrayOfDataArrays(visibleGraphNames);
      var newMax = getMaxValue(viewBox, arrayOfDataArrays); // Maybe add onComplete callback to cleanup cancelAnimation and currentAnimationTarget

      if (max !== newMax && newMax !== currentAnimationTarget) {
        if (cancelAnimation) cancelAnimation();
        currentAnimationTarget = newMax;
        cancelAnimation = animate(max, newMax, transitionDuration, updateStateAndRender);
      } else {
        render();
      }
    }

    function updateStateAndRender(newMax) {
      max = newMax;
      if (yAxis) yAxis.setMax(newMax);
      render();
    } // function setYScale (yScale) {}
    // function setViewBox (viewBox) {}
    // yScale


    function render() {
      for (var _i3 = 0; _i3 < config.graphNames.length; _i3++) {
        var graphName = config.graphNames[_i3];
        canvases[graphName].clear();
        canvases[graphName].renderPath(mapDataToCoords(config.data[graphName], max, {
          width: width * devicePixelRatio,
          height: height * devicePixelRatio
        }, viewBox));
      }
    } // all data has already been precolulated
    // coords are sorted, can use binary search here
    // need input y here, not screen offset


    function onContainerMouseMove(e) {
      if (dragging) return;
      var visibleGraphNames = config.graphNames.filter(function (graphName) {
        return config.visibilityState[graphName];
      });
      if (!visibleGraphNames.length) return;
      tooltipLine.show();
      var arrayOfDataArrays = getArrayOfDataArrays(visibleGraphNames);
      var coords = mapDataToCoords(config.data[visibleGraphNames[0]], max, {
        width: width * devicePixelRatio,
        height: height * devicePixelRatio
      }, viewBox);
      var newLeft = (e.clientX - canvasesContainer.getBoundingClientRect().x) * devicePixelRatio;
      var closestPointIndex = 0;

      for (var _i4 = 1; _i4 < coords.length; _i4++) {
        if (Math.abs(newLeft - coords[_i4].x) < Math.abs(newLeft - coords[closestPointIndex].x)) closestPointIndex = _i4;
      }

      var values = {};

      for (var _i5 = 0; _i5 < visibleGraphNames.length; _i5++) {
        var graphName = visibleGraphNames[_i5];
        var thisCoords = mapDataToCoords(config.data[graphName], max, {
          width: width * devicePixelRatio,
          height: height * devicePixelRatio
        }, viewBox);
        tooltipDots[graphName].show(); // xShift can be calculated once for all points

        var x = thisCoords[closestPointIndex].x / devicePixelRatio;
        var y = thisCoords[closestPointIndex].y / devicePixelRatio;

        tooltipDots[visibleGraphNames[_i5]].setPosition({
          x: x,
          y: y
        });

        tooltip.show();
        tooltip.setPosition(x);
        var dataIndex = closestPointIndex + Math.floor(viewBox.startIndex);
        tooltip.setDate(config.domain[dataIndex]);
        values[graphName] = config.data[graphName][dataIndex];
      }

      tooltip.showValues(values);
      tooltipLine.setPosition(coords[closestPointIndex].x / devicePixelRatio);
    }

    function onContainerMouseOut() {
      tooltipLine.hide();
      tooltip.hide();
      Object.values(tooltipDots).forEach(function (dot) {
        return dot.hide();
      });
    }

    function toggleVisibility(graphName) {
      canvases[graphName].toggleVisibility();
      var visibleGraphNames = config.graphNames.filter(function (graphName) {
        return config.visibilityState[graphName];
      });
      emprtState.setVisibile(visibleGraphNames.length);
      transitionDuration = TRANSITION_DURATIONS[TOGGLE_VISIBILITY_STATE];
      update();
    }

    function changeViewBox(newViewBox) {
      Object.assign(viewBox, newViewBox);

      if (xAxis) {
        xAxis.setViewBox(viewBox);
      }

      transitionDuration = TRANSITION_DURATIONS[VIEW_BOX_CHANGE];
      update();
    }

    function getXAxisPoints() {
      return config.domain.map(function (timestamp, index) {
        return {
          x: width / (config.domain.length - 1) * index,
          label: getLabelText(timestamp)
        };
      });
    }

    function getArrayOfDataArrays(graphNames) {
      var arrayOfDataArrays = [];

      for (var _i6 = 0; _i6 < graphNames.length; _i6++) {
        arrayOfDataArrays.push(config.data[graphNames[_i6]]);
      }

      return arrayOfDataArrays;
    }

    function startDrag() {
      tooltip.hide();
      tooltipLine.hide();

      for (var _i7 = 0; _i7 < config.graphNames.length; _i7++) {
        tooltipDots[config.graphNames[_i7]].hide();
      }

      dragging = true;
    }

    function stopDrag() {
      dragging = false;
    }
  }

  function getLabelText(timestamp) {
    var date = new Date(timestamp);
    return "".concat(MONTHS[date.getMonth()], " ").concat(date.getDate());
  }

  var minimalPixelsBetweenResizers = 40;
  var classes = {
    left: 'cursor-w-resize',
    right: 'cursor-e-resize',
    grabbing: 'cursor-grabbing'
  };
  var ELEMENT_CLASS_NAME$1 = 'overview';
  var VIEWBOX_TOP_BOTTOM_BORDER_WIDTH = 4;

  function Overview(chartConfig, onViewBoxChange, onDragStart, onDragEnd) {
    var overviewContainer = div();
    overviewContainer.className = ELEMENT_CLASS_NAME$1;
    overviewContainer.style.height = "".concat(chartConfig.OVERVIEW_CANVAS_HEIGHT, "px");
    var graphs = Graphs(chartConfig, {
      width: chartConfig.OVERVIEW_CANVAS_WIDTH,
      height: chartConfig.OVERVIEW_CANVAS_HEIGHT - VIEWBOX_TOP_BOTTOM_BORDER_WIDTH * 2,
      top: VIEWBOX_TOP_BOTTOM_BORDER_WIDTH,
      strokeStyles: chartConfig.colors,
      lineWidth: chartConfig.OVERVIEW_LINE_WIDTH,
      viewBox: {
        startIndex: 0,
        endIndex: chartConfig.data.total - 1
      }
    });
    overviewContainer.appendChild(graphs.element);
    var backgroundLeft = createElement('div', {
      className: 'overview__overflow overview__overflow--left'
    });
    var backgroundRight = createElement('div', {
      className: 'overview__overflow overview__overflow--right'
    });
    var resizerLeft = createElement('div', {
      className: 'overview__resizer overview__resizer--left'
    });
    var resizerRight = createElement('div', {
      className: 'overview__resizer overview__resizer--right'
    });
    var viewBoxElement = createElement('div', {
      className: 'overview__viewbox'
    }, [resizerLeft, resizerRight]);
    overviewContainer.appendChild(backgroundLeft);
    overviewContainer.appendChild(backgroundRight);
    overviewContainer.appendChild(viewBoxElement);
    var overviewState = {
      left: chartConfig.viewBox.startIndex / (chartConfig.data.total - 1) * chartConfig.OVERVIEW_CANVAS_WIDTH,
      right: chartConfig.OVERVIEW_CANVAS_WIDTH,
      cursorResizerDelta: 0,
      cursorViewBoxElementDelta: 0
    };
    backgroundLeft.style.width = "".concat(overviewState.left, "px");
    viewBoxElement.style.left = "".concat(overviewState.left, "px");
    handleDrag(resizerLeft, {
      onDragStart: onLeftResizerMouseDown,
      onDragMove: onLeftResizerMouseMove,
      onDragEnd: removeLeftResizerListener
    });
    handleDrag(resizerRight, {
      onDragStart: onRightResizerMouseDown,
      onDragMove: onRightResizerMouseMove,
      onDragEnd: removeRightResizerListener
    });
    handleDrag(viewBoxElement, {
      onDragStart: onViewBoxElementMouseDown,
      onDragMove: onViewBoxElementMouseMove,
      onDragEnd: onViewBoxElementMouseUp
    });
    return {
      element: overviewContainer,
      toggleVisibility: graphs.toggleVisibility
    };

    function onLeftResizerMouseDown(e) {
      onDragStart();
      document.body.classList.add(classes.left);
      viewBoxElement.classList.add(classes.left);
      overviewState.cursorResizerDelta = getX(e) - (resizerLeft.getBoundingClientRect().left - overviewContainer.getBoundingClientRect().left);
    }

    function removeLeftResizerListener() {
      onDragEnd();
      document.body.classList.remove(classes.left);
      viewBoxElement.classList.remove(classes.left);
    }

    function onLeftResizerMouseMove(e) {
      var left = ensureInOverviewBounds(getX(e) - overviewState.cursorResizerDelta);
      overviewState.left = left > overviewState.right - minimalPixelsBetweenResizers ? overviewState.right - minimalPixelsBetweenResizers : left;
      backgroundLeft.style.width = "".concat(overviewState.left, "px");
      viewBoxElement.style.left = "".concat(overviewState.left, "px");
      var startIndex = overviewState.left / chartConfig.OVERVIEW_CANVAS_WIDTH * (chartConfig.data.total - 1);
      onViewBoxChange({
        startIndex: startIndex
      });
    }

    function onRightResizerMouseDown(e) {
      onDragStart();
      document.body.classList.add(classes.right);
      viewBoxElement.classList.add(classes.right);
      overviewState.cursorResizerDelta = getX(e) - (resizerRight.getBoundingClientRect().right - overviewContainer.getBoundingClientRect().left);
    }

    function removeRightResizerListener() {
      onDragEnd();
      document.body.classList.remove(classes.right);
      viewBoxElement.classList.remove(classes.right);
    }

    function onRightResizerMouseMove(e) {
      var right = ensureInOverviewBounds(getX(e) - overviewState.cursorResizerDelta);
      overviewState.right = right < overviewState.left + minimalPixelsBetweenResizers ? overviewState.left + minimalPixelsBetweenResizers : right;
      backgroundRight.style.left = "".concat(overviewState.right, "px");
      viewBoxElement.style.right = "".concat(chartConfig.OVERVIEW_CANVAS_WIDTH - overviewState.right, "px");
      var endIndex = overviewState.right / chartConfig.OVERVIEW_CANVAS_WIDTH * (chartConfig.data.total - 1);
      onViewBoxChange({
        endIndex: endIndex
      });
    }

    function getX(event) {
      var _overviewContainer$ge = overviewContainer.getBoundingClientRect(),
          left = _overviewContainer$ge.left;

      return event.clientX - left + window.scrollX - document.documentElement.scrollLeft;
    }

    function ensureInOverviewBounds(x) {
      if (x > chartConfig.OVERVIEW_CANVAS_WIDTH) return chartConfig.OVERVIEW_CANVAS_WIDTH;
      if (x < 0) return 0;
      return x;
    }

    function onViewBoxElementMouseDown(e) {
      onDragStart();
      overviewState.cursorViewBoxElementDelta = getX(e) - (viewBoxElement.getBoundingClientRect().left - overviewContainer.getBoundingClientRect().left), viewBoxElement.classList.add(classes.grabbing);
      document.body.classList.add(classes.grabbing);
      resizerLeft.classList.add(classes.grabbing);
      resizerRight.classList.add(classes.grabbing);
    }

    function onViewBoxElementMouseUp() {
      onDragEnd();
      document.body.classList.remove(classes.grabbing);
      viewBoxElement.classList.remove(classes.grabbing);
      resizerLeft.classList.remove(classes.grabbing);
      resizerRight.classList.remove(classes.grabbing);
    }

    function onViewBoxElementMouseMove(e) {
      var width = overviewState.right - overviewState.left;
      var nextLeft = getX(e) - overviewState.cursorViewBoxElementDelta;

      if (nextLeft < 0) {
        overviewState.left = 0;
      } else if (nextLeft > chartConfig.OVERVIEW_CANVAS_WIDTH - width) {
        overviewState.left = chartConfig.OVERVIEW_CANVAS_WIDTH - width;
      } else {
        overviewState.left = nextLeft;
      }

      overviewState.right = overviewState.left + width;
      viewBoxElement.style.left = "".concat(overviewState.left, "px");
      viewBoxElement.style.right = "".concat(chartConfig.OVERVIEW_CANVAS_WIDTH - overviewState.right, "px");
      backgroundLeft.style.width = "".concat(overviewState.left, "px");
      backgroundRight.style.left = "".concat(overviewState.right, "px");
      var startIndex = overviewState.left / chartConfig.OVERVIEW_CANVAS_WIDTH * (chartConfig.data.total - 1);
      var endIndex = overviewState.right / chartConfig.OVERVIEW_CANVAS_WIDTH * (chartConfig.data.total - 1);
      onViewBoxChange({
        startIndex: startIndex,
        endIndex: endIndex
      });
    }
  }

  function Controls(config, onButtonClick) {
    return createElement('div', {
      style: 'margin-top: 20px'
    }, config.graphNames.map(function (graphName) {
      return createElement('label', {
        style: "color: ".concat(config.colors[graphName], "; margin-right: 20px")
      }, [createElement('input', {
        checked: true,
        type: 'checkbox',
        className: 'button',
        onclick: function onclick() {
          return onButtonClick(graphName);
        }
      }), createElement('div', {
        className: 'like-button'
      }, [createElement('div', {
        className: 'button-text',
        innerText: graphName
      })])]);
    }));
  }

  function Chart(chartConfig) {
    var element = document.createElement('div');
    element.style.marginTop = '110px';
    element.appendChild(Title(chartConfig.title));
    var graphs = Graphs(chartConfig, {
      width: chartConfig.width,
      height: chartConfig.height,
      lineWidth: chartConfig.lineWidth,
      strokeStyles: chartConfig.colors,
      viewBox: chartConfig.viewBox,
      showXAxis: true,
      showYAxis: true,
      showTooltip: true // colors: chartConfig.colors,
      // graphNames: chartConfig.graphNames,
      // data: chartConfig.data,
      // domain: chartConfig.domain,
      // visibleGraphNames: get ()
      // maxVisibleValue: get ()

    });
    var overview = Overview(chartConfig, onViewBoxChange, onDragStart, onDragEnd);
    element.appendChild(graphs.element);
    element.appendChild(overview.element);
    element.appendChild(Controls(chartConfig, onButtonClick));
    return {
      element: element
    };

    function onButtonClick(graphName) {
      chartConfig.visibilityState[graphName] = !chartConfig.visibilityState[graphName];
      graphs.toggleVisibility(graphName);
      overview.toggleVisibility(graphName);
    }

    function onViewBoxChange(viewBox) {
      graphs.changeViewBox(viewBox);
    }

    function onDragStart() {
      graphs.startDrag();
    }

    function onDragEnd() {
      graphs.stopDrag();
    }
  }

  var NEXT_THEME = (_NEXT_THEME = {}, _defineProperty(_NEXT_THEME, LIGHT, DARK), _defineProperty(_NEXT_THEME, DARK, LIGHT), _NEXT_THEME);
  var LABELS = (_LABELS = {}, _defineProperty(_LABELS, LIGHT, 'Switch to Night Mode'), _defineProperty(_LABELS, DARK, 'Switch to Day Mode'), _LABELS);
  var THEME_CLASS_NAMES = (_THEME_CLASS_NAMES = {}, _defineProperty(_THEME_CLASS_NAMES, LIGHT, 'theme-light'), _defineProperty(_THEME_CLASS_NAMES, DARK, 'theme-dark'), _THEME_CLASS_NAMES);
  var ELEMENT_CLASS_NAME$2 = 'theme-switcher';

  function ThemeSwitcher(initialTheme) {
    var theme = initialTheme;
    var button = document.createElement('button');
    button.innerText = LABELS[theme];
    button.classList.add(ELEMENT_CLASS_NAME$2);
    button.addEventListener('click', function () {
      document.body.classList.remove(THEME_CLASS_NAMES[theme]);
      theme = NEXT_THEME[theme];
      button.innerText = LABELS[theme];
      document.body.classList.add(THEME_CLASS_NAMES[theme]);
    });
    return button;
  }

  var LINE_WIDTH$1 = 2;
  var OVERVIEW_LINE_WIDTH = 1;
  var CANVAS_WIDTH = 768;
  var CANVAS_HEIGHT = 300;
  var OVERVIEW_CANVAS_HEIGHT = 50;
  var OVERVIEW_CANVAS_WIDTH = CANVAS_WIDTH;

  function createChartConfig(chartData) {
    var graphNames = chartData['columns'].map(function (column) {
      return column[0];
    }).filter(function (graphName) {
      return chartData['types'][graphName] === 'line';
    });
    var domain = chartData['columns'].find(function (column) {
      return column[0] === 'x';
    }).slice(1);
    var data = chartData['columns'].reduce(function (data, column) {
      var _objectSpread2;

      return _objectSpread({}, data, (_objectSpread2 = {}, _defineProperty(_objectSpread2, column[0], column.slice(1)), _defineProperty(_objectSpread2, "total", max(data.total, column.length - 1)), _objectSpread2));
    }, {
      total: 0
    });
    var visibilityState = graphNames.reduce(function (visibilityState, graphName) {
      return _objectSpread({}, visibilityState, _defineProperty({}, graphName, true));
    }, {});
    var viewBox = {
      startIndex: ceil(data.total / 3 * 2),
      endIndex: data.total - 1
    };
    return {
      title: 'Followers',
      data: data,
      domain: domain,
      graphNames: graphNames,
      visibilityState: visibilityState,
      viewBox: viewBox,
      colors: chartData['colors'],
      width: CANVAS_WIDTH,
      height: CANVAS_HEIGHT,
      lineWidth: LINE_WIDTH$1,
      OVERVIEW_CANVAS_WIDTH: OVERVIEW_CANVAS_WIDTH,
      OVERVIEW_CANVAS_HEIGHT: OVERVIEW_CANVAS_HEIGHT,
      OVERVIEW_LINE_WIDTH: OVERVIEW_LINE_WIDTH
    };
  }

  document.body.appendChild(ThemeSwitcher(DARK)); // 1/3, 1/2, 1/3, 1/3, 1/2
  // Chart(createChartConfig(chartData[0]))

  chartData.map(function (data) {
    return Chart(createChartConfig(data));
  }).forEach(function (chart) {
    return document.body.appendChild(chart.element);
  });
})();